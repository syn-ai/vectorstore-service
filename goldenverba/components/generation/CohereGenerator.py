import asyncio
import os
from collections.abc import Iterator

from wasabi import msg

from goldenverba.components.generation.interface import Generator


class CohereGenerator(Generator):
    """
    CohereGenerator Generator.
    """

    def __init__(self):
        super().__init__()
        self.name = "CohereGenerator"
        self.description = "Generator using Cohere's command model"
        self.requires_library = ["cohere"]
        self.requires_env = ["COHERE_API_KEY"]
        self.streamable = False
        self.model_name = "command"
        self.context_window = 3000

    async def generate(
        self,
        queries: list[str],
        context: list[str],
        conversation: dict = None,
    ) -> str:
        """Generate an answer based on a list of queries and list of contexts, and includes conversational context
        @parameter: queries : list[str] - List of queries
        @parameter: context : list[str] - List of contexts
        @parameter: conversation : dict - Conversational context
        @returns str - Answer generated by the Generator.
        """
        if conversation is None:
            conversation = {}
        message, _conversation = self.prepare_messages(queries, context, conversation)

        try:
            import cohere

            co = cohere.Client(os.getenv("COHERE_API_KEY"))

            # This is your synchronous chat function call.
            def synchronous_chat_call():
                # ... setup your parameters for the call ...
                return co.chat(
                    chat_history=_conversation,
                    message=message,
                    model="command",
                    temperature=0.1,
                )

            # This is your async wrapper function.
            async def asynchronous_chat_call():
                chat_obj = await asyncio.to_thread(synchronous_chat_call)
                return chat_obj

            chat_obj = await asynchronous_chat_call()

            system_msg = str(chat_obj.text)

        except Exception:
            raise

        return system_msg

    async def generate_stream(
        self,
        queries: list[str],
        context: list[str],
        conversation: dict = None,
    ) -> Iterator[dict]:
        """Generate a stream of response dicts based on a list of queries and list of contexts, and includes conversational context
        @parameter: queries : list[str] - List of queries
        @parameter: context : list[str] - List of contexts
        @parameter: conversation : dict - Conversational context
        @returns Iterator[dict] - Token response generated by the Generator in this format {system:TOKEN, finish_reason:stop or empty}.
        """
        if conversation is None:
            conversation = {}
        message, _conversation = self.prepare_messages(queries, context, conversation)

        try:
            import cohere
            from cohere.responses.chat import StreamEnd, StreamTextGeneration

            co = cohere.Client(os.getenv("COHERE_API_KEY"))

            async for chunk in co.chat(
                chat_history=_conversation,
                stream=True,
                message=message,
                model="command",
                temperature=0.1,
            ):
                if isinstance(chunk, StreamTextGeneration):
                    yield {
                        "message": chunk.text,
                        "finish_reason": "",
                    }
                elif isinstance(chunk, StreamEnd):
                    yield {
                        "message": "",
                        "finish_reason": "stop",
                    }

        except Exception as e:
            raise
            msg.warn(str(e))
            yield {
                "message": "",
                "finish_reason": "stop",
            }

    def prepare_messages(
        self, queries: list[str], context: list[str], conversation: dict[str, str]
    ) -> dict[str, str]:
        """
        Prepares a list of messages formatted for a Retrieval Augmented Generation chatbot system, including system instructions, previous conversation, and a new user query with context.

        @parameter queries: A list of strings representing the user queries to be answered.
        @parameter context: A list of strings representing the context information provided for the queries.
        @parameter conversation: A list of previous conversation messages that include the role and content.

        @returns A list of message dictionaries formatted for the chatbot. This includes an initial system message, the previous conversation messages, and the new user query encapsulated with the provided context.

        Each message in the list is a dictionary with 'role' and 'content' keys, where 'role' is either 'system' or 'user', and 'content' contains the relevant text. This will depend on the LLM used.
        """
        messages = [
            {
                "role": "CHATBOT",
                "message": "I am a Retrieval Augmented Generation chatbot. I'll answer user queries only with their provided context. If the provided documentation does not provide enough information, I say so. If the answer requires code examples I encapsulate them with ```programming-language-name ```. I don't do pseudo-code.",
            }
        ]

        for message in conversation:
            _type = ""
            _type = "CHATBOT" if message.type == "system" else "USER"

            messages.append({"role": _type, "message": message.content})

        query = " ".join(queries)
        user_context = " ".join(context)

        prompt = f"Please answer this query: '{query}' with this provided context: {user_context}"

        return prompt, messages
